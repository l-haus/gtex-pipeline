[0m[1mrandom_id.suffix: Refreshing state... [id=nJE][0m
[0m[1mgoogle_project_service.apis["storage.googleapis.com"]: Refreshing state... [id=gtex-pipeline/storage.googleapis.com][0m
[0m[1mgoogle_service_account.airflow: Refreshing state... [id=projects/gtex-pipeline/serviceAccounts/airflow-bucket-rw@gtex-pipeline.iam.gserviceaccount.com][0m
[0m[1mgoogle_project_service.apis["iam.googleapis.com"]: Refreshing state... [id=gtex-pipeline/iam.googleapis.com][0m
[0m[1mgoogle_storage_bucket.data: Refreshing state... [id=rna-dev-9c91][0m
[0m[1mgoogle_storage_bucket_iam_member.sa_rw: Refreshing state... [id=b/rna-dev-9c91/roles/storage.objectAdmin/serviceAccount:airflow-bucket-rw@gtex-pipeline.iam.gserviceaccount.com][0m

Terraform used the selected providers to generate the following execution
plan. Resource actions are indicated with the following symbols:
  [32m+[0m create[0m

Terraform will perform the following actions:

[1m  # google_service_account_iam_member.airflow_wi[0m will be created
[0m  [32m+[0m[0m resource "google_service_account_iam_member" "airflow_wi" {
      [32m+[0m[0m etag               = (known after apply)
      [32m+[0m[0m id                 = (known after apply)
      [32m+[0m[0m member             = "serviceAccount:gtex-pipeline.svc.id.goog[rnaseq/airflow-runner]"
      [32m+[0m[0m role               = "roles/iam.workloadIdentityUser"
      [32m+[0m[0m service_account_id = "projects/gtex-pipeline/serviceAccounts/airflow-bucket-rw@gtex-pipeline.iam.gserviceaccount.com"
    }

[1mPlan:[0m 1 to add, 0 to change, 0 to destroy.
[0m[90m
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[0m

Note: You didn't use the -out option to save this plan, so Terraform can't
guarantee to take exactly these actions if you run "terraform apply" now.
